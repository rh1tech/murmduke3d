; PS/2 Receive Program - Generic version using IN pins for both wait and sample
; 
; Pin assignment (consecutive pins required):
;   IN pin base = CLK pin  (pin 0 in PIO terms)
;   IN pin base + 1 = DATA pin (pin 1 in PIO terms)
;
; The program samples 2 bits at each clock edge (CLK and DATA together).
; Software extracts the DATA bit (bit 1 of each 2-bit sample).
;
; Protocol: 11 clock cycles = 1 start + 8 data + 1 parity + 1 stop
; Total bits captured: 11 samples * 2 bits = 22 bits per frame
;
; SPDX-License-Identifier: GPL-2.0-or-later

.program ps2_rx

.wrap_target
start:
    wait 1 pin 0        ; Wait for CLK high (idle state)
    wait 0 pin 0        ; Wait for CLK falling edge (start bit begins)
    
    set x, 10           ; 11 bits total (0-10 inclusive)
bitloop:
    ; Small delay to let data line settle after clock edge
    nop
    nop
    in pins, 2          ; Sample CLK (bit 0) and DATA (bit 1)
    wait 1 pin 0        ; Wait for CLK to go high
    jmp x-- continue    ; Decrement and check
    push                ; All 11 samples collected, push 22 bits to FIFO
    jmp start           ; Start over
continue:
    wait 0 pin 0        ; Wait for next CLK falling edge
    jmp bitloop
.wrap

% c-sdk {
#include "hardware/pio.h"
#include "hardware/clocks.h"

/**
 * Initialize PS/2 receive state machine.
 * 
 * @param pio      PIO instance (pio0 or pio1)
 * @param sm       State machine number (0-3)
 * @param offset   Program offset in PIO instruction memory
 * @param clk_pin  GPIO pin for PS/2 clock (DATA must be clk_pin + 1)
 */
static inline void ps2_rx_program_init(PIO pio, uint sm, uint offset, uint clk_pin) {
    uint data_pin = clk_pin + 1;
    
    pio_sm_config c = ps2_rx_program_get_default_config(offset);
    
    // IN pin base = CLK pin, so:
    //   'wait N pin 0' checks CLK
    //   'in pins, 2' reads CLK (bit 0) and DATA (bit 1)
    sm_config_set_in_pins(&c, clk_pin);
    
    // Shift LEFT, autopush after 22 bits (11 samples * 2 bits)
    // Left shift puts first sample in LSB, which makes decoding easier
    sm_config_set_in_shift(&c, false, true, 22);
    
    // Join FIFOs for deeper RX buffer (32 entries)
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);
    
    // Clock divider: PS/2 runs at 10-16.7 kHz
    // We want at least 8 SM cycles per PS/2 clock for reliable sampling
    float div = (float)clock_get_hz(clk_sys) / (8.0f * 16700.0f);
    sm_config_set_clkdiv(&c, div);
    
    // Initialize GPIO pins for PIO
    pio_gpio_init(pio, clk_pin);
    pio_gpio_init(pio, data_pin);
    
    // Set pins as inputs
    pio_sm_set_consecutive_pindirs(pio, sm, clk_pin, 2, false);
    
    // Enable internal pull-ups (PS/2 is open-collector)
    gpio_pull_up(clk_pin);
    gpio_pull_up(data_pin);
    
    // Initialize and enable state machine
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

/**
 * Extract data byte from raw 22-bit PIO frame.
 * 
 * With LEFT shift, first sample (start) is at highest bits:
 *   Bits 21:20 = Sample 0 (start bit)
 *   Bits 19:18 = Sample 1 (data bit 0)
 *   ...
 *   Bits 1:0   = Sample 10 (stop bit)
 * 
 * Each sample has CLK in bit 0, DATA in bit 1.
 * 
 * Returns: data byte if valid, -1 if frame error, -2 if parity error
 */
static inline int ps2_rx_decode_frame(uint32_t raw) {
    // Extract each DATA bit (bit 1 of each 2-bit sample)
    // First sample is at highest position due to left shift
    uint8_t start  = (raw >> 21) & 1;  // Sample 0
    uint8_t d0     = (raw >> 19) & 1;  // Sample 1
    uint8_t d1     = (raw >> 17) & 1;  // Sample 2
    uint8_t d2     = (raw >> 15) & 1;  // Sample 3
    uint8_t d3     = (raw >> 13) & 1;  // Sample 4
    uint8_t d4     = (raw >> 11) & 1;  // Sample 5
    uint8_t d5     = (raw >> 9) & 1;   // Sample 6
    uint8_t d6     = (raw >> 7) & 1;   // Sample 7
    uint8_t d7     = (raw >> 5) & 1;   // Sample 8
    uint8_t parity = (raw >> 3) & 1;   // Sample 9
    uint8_t stop   = (raw >> 1) & 1;   // Sample 10
    
    // Validate start bit (must be 0) and stop bit (must be 1)
    if (start != 0 || stop != 1) {
        return -1;  // Frame error
    }
    
    // Reconstruct data byte (PS/2 sends LSB first)
    uint8_t data = d0 | (d1 << 1) | (d2 << 2) | (d3 << 3) |
                   (d4 << 4) | (d5 << 5) | (d6 << 6) | (d7 << 7);
    
    // Verify odd parity
    uint8_t calc_parity = 1;
    uint8_t temp = data;
    while (temp) {
        calc_parity ^= (temp & 1);
        temp >>= 1;
    }
    
    if (parity != calc_parity) {
        return -2;  // Parity error
    }
    
    return data;
}
%}

